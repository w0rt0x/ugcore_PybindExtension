<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ug4: Categorization of Problems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page_l_d_categorization.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Categorization of Problems </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In order to discretize a problem as presented in <a class="el" href="page_l_d_assembling_concept.html#secGeneralProblemDescribtion">General Problem Description</a> the different problems can be categorized into several classes. All classes of problems can be implemented in a general framework.</p>
<ul>
<li><a class="el" href="page_l_d_categorization.html#secDomainDiscretization">Domain Discretizaion</a></li>
<li><a class="el" href="page_l_d_categorization.html#secStationaryLinearDiscretization">Linear Stationary Problems</a></li>
<li><a class="el" href="page_l_d_categorization.html#secStationaryNonLinearDiscretization">Non-Linear Stationary Problems</a></li>
<li><a class="el" href="page_l_d_categorization.html#secTimeDiscretization">Time Discretization</a></li>
<li><a class="el" href="page_l_d_categorization.html#secTimeDependentLinearDiscretization">Time-Dependent Linear Problems</a></li>
<li><a class="el" href="page_l_d_categorization.html#secTimeDependentNonLinearDiscretization">Time-Dependent Non-Linear Problems</a></li>
</ul>
<p><br  />
</p>
<hr  />
 <h1><a class="anchor" id="secDomainDiscretization"></a>
Domain Discretization</h1>
<hr  />
<p>Let the Domain <img class="formulaInl" alt="$\Omega$" src="form_0.png"/> be covered by a grid <img class="formulaInl" alt="$\Omega_h$" src="form_1.png"/>. By choosing an appropriate trial space, each unknown continuous function <img class="formulaInl" alt="$u_i(\vec{x},t)$" src="form_2.png"/> is now approximated by an finite-dimensional numerical function <img class="formulaInl" alt="$u_{h,i}(\vec{x},t)$" src="form_3.png"/>. For each function <img class="formulaInl" alt="$u_{h,i}$" src="form_4.png"/> a certain number of degrees of freedoms (DoF) has to distributed on the grid, being associated with the geometric objects. For example, one can think of piecewise linear functions on each grid elements, requiring one DoF per vertex of the element and no DoFs on the other Geometric Objects like edges or faces. Let <img class="formulaInl" alt="$N_{h,i}$" src="form_5.png"/> be the number of DoFs needed to represent the unknowns of the i'th function and let <img class="formulaInl" alt="$N_h = \sum_{i=1}^n N_{h,i}$" src="form_6.png"/> be the number DoFs needed for the whole problem. Each discrete function <img class="formulaInl" alt="$u_{h,i}$" src="form_4.png"/> is isomorphic to a representation in <img class="formulaInl" alt="$\mathbb{R}^{N_{h,i}}$" src="form_7.png"/>, thus it can be represented by an algebraic vector <img class="formulaInl" alt="$\vec{u}_{h,i} \in \mathbb{R}^{N_{h,i}}$" src="form_8.png"/> and the entries of the vector <img class="formulaInl" alt="$(\vec{u}_{h,i})_j \in \mathbb{R}$" src="form_9.png"/> are the DoFs of the function. By the same construction a representation for the system solution can be found.</p>
<p>To facilitate notations for the remainder of this page, let <img class="formulaInl" alt="$\vec{u} = \vec{u}_1$" src="form_10.png"/>, i.e. it is a scalar problem. For systems of unknowns the ideas are straight forward. <br  />
</p>
<p>For the discretization of the PDE there are several possibilities.</p>
<ul>
<li>
finite difference method (FD) </li>
<li>
finite element method (FE) </li>
<li>
finite volume method (FV) </li>
<li>
discontinuous galerkin method (DG) </li>
</ul>
<p>This gives rise to discretized operators <img class="formulaInl" alt="$\mathcal{M}_h(\cdot)$" src="form_11.png"/> and <img class="formulaInl" alt="$\mathcal{A}_h(\cdot)$" src="form_12.png"/> and a discrete right-hand side <img class="formulaInl" alt="$\vec{f_h}$" src="form_13.png"/>, with <img class="formulaInl" alt="$ \mathcal{M}_h, \mathcal{A}_h: \mathbb{R}^{N_h} \mapsto \mathbb{R}^{N_h} $" src="form_14.png"/> and <img class="formulaInl" alt="$\vec{f_h} \in \mathbb{R}^{N_h}$" src="form_15.png"/>.</p>
<p>The discrete problem can be written as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \partial_t \mathcal{M}_h(\vec{u}_h) + \mathcal{A}_h(\vec{u}_h) = \vec{f_h} \end{align*}" src="form_16.png"/>
</p>
<p> Note, that the boundary conditions are taken into account in the operators and the right-hand side.</p>
<hr  />
 <h1><a class="anchor" id="secStationaryLinearDiscretization"></a>
Linear Stationary Problems - the easiest case</h1>
<p>The easiest case are time-independent (stationary) and linear problems. This means </p><ul>
<li>
stationary: <img class="formulaInl" alt="$ \mathcal{M}_h(\cdot) = 0 $" src="form_17.png"/> </li>
<li>
linear: <img class="formulaInl" alt="$ \mathcal{A}_h(\vec{u}_h) \equiv A_h \cdot \vec{u}_h $" src="form_18.png"/>, i.e. <img class="formulaInl" alt="$A_h \in \mathbb{R}^{N_h \times N_h}$" src="form_19.png"/> is a matrix </li>
</ul>
<p>In this case the "Stiffness-Matrix" <img class="formulaInl" alt="$A_h$" src="form_20.png"/> and the right-hand side vector <img class="formulaInl" alt="$\vec{f}_h \in \mathbb{R}^{N_h}$" src="form_21.png"/> has to be assembled. Then, it remains to use an adequate matrix solver to solve the linear system </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} A_h \vec{u}_h = \vec{f}_h. \end{align*}" src="form_22.png"/>
</p>
<p>In order to specify a problem, the user has to supply: </p><ul>
<li>
the computation of the matrix <img class="formulaInl" alt="$A_h$" src="form_20.png"/> </li>
<li>
the computation of the rhs <img class="formulaInl" alt="$\vec{f}_h$" src="form_23.png"/> </li>
</ul>
<p>The solution of the algebraic problem (inverting <img class="formulaInl" alt="$A_h$" src="form_20.png"/>) can be implemented independently from the actual problem and/or discretization.</p>
<hr  />
 <h1><a class="anchor" id="secStationaryNonLinearDiscretization"></a>
Non-Linear Stationary Problems</h1>
<p>Stationary, non-linear problems are described by </p><ul>
<li>
stationary: <img class="formulaInl" alt="$ \mathcal{M}_h(\cdot) = 0 $" src="form_17.png"/> </li>
<li>
non-linear: <img class="formulaInl" alt="$ \mathcal{A}_h(\vec{u}_h): \mathbb{R}^{N_h} \mapsto \mathbb{R}^{N_h}$" src="form_24.png"/> can not be represented as matrix </li>
</ul>
<p>Thus, in order to solve this problem typically a newton-method is used. This means to reformulate the problem using the "defect": </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} d_h: \mathbb{R}^{N_h} &amp;\mapsto \mathbb{R}^{N_h}\\ \vec{u}_h &amp;\mapsto \vec{d}_h(\vec{u}_h) := \mathcal{A}_h(\vec{u}_h)-\vec{f}_h. \end{align*}" src="form_25.png"/>
</p>
<p> The aim is to find a root <img class="formulaInl" alt="$\vec{d}_h(u_h) = 0$" src="form_26.png"/> of the defect. This is usually solved by the Newton method or some kind of fixed-point iteration. Starting with an initial guess <img class="formulaInl" alt="$u_h^0$" src="form_27.png"/> the following interation is performed </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \vec{c}_{h,k} &amp;:= (J_h(\vec{u}_{h_k}))^{-1} d_h(\vec{u}_{h,k}),\\ \vec{u}_{h,k+1} &amp;:= \vec{u}_{h,k} - \alpha_k \vec{c}_{h,k} \end{align*}" src="form_28.png"/>
</p>
<p> with </p><ul>
<li>
<img class="formulaInl" alt="$\vec{u}_{h,k}$" src="form_29.png"/> is the k'th iterate of the solution </li>
<li>
<img class="formulaInl" alt="$\vec{c}_{h,k}$" src="form_30.png"/> is the k'th correction </li>
<li>
<img class="formulaInl" alt="$J_h(\vec{u}_{h_k})$" src="form_31.png"/> is a preconditioner matrix for the linearization of the defect w.r.t. the DoFs, evaluated at the solution of the current iterate </li>
<li>
<img class="formulaInl" alt="$ \alpha_k$" src="form_32.png"/> is a damping factor </li>
</ul>
<p>There are several choises of <img class="formulaInl" alt="$J_h(\vec{u}_{h_k})$" src="form_31.png"/>: </p><ul>
<li>
<p class="startli">Jacobian </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} J_h(\vec{u}_{h_k}) = \frac{\partial \vec{d}_h(u_h)}{\partial \vec{u}_h} = \frac{\partial \mathcal{A}_h(u_h)}{\partial \vec{u}_h} \end{align*}" src="form_33.png"/>
</p>
<p> The Jacobian is the linearization of the defect with respect to the unknown DoFs, i.e. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} (J_h(\vec{u}_{h_k}))_{ij} = \frac{\partial (\vec{d}_h(u_h))_i}{\partial (\vec{u}_h)_j} \end{align*}" src="form_34.png"/>
</p>
<p class="endli"></p>
</li>
<li>
Identity <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} J_h(\vec{u}_{h_k}) = \mathbb{I} \end{align*}" src="form_35.png"/>
</p>
 This gives rise to a very simple fixed-point iteration. </li>
</ul>
<p>Between these two methods, a lot of different approaches by neglecting terms of the exact jacobian. Choosing the Jacobian as a preconditioner will result in a quadratic convergence rate of the iteration. The other schemes give only a linear convergence rate.</p>
<p>One major part of the non-linear iteration is the solution of the linear problem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} J_h(\vec{u}_{h_k}) \vec{c}_{h,k} = \vec{d}_h(\vec{u}_{h_k}). \end{align*}" src="form_36.png"/>
</p>
<p> This problem has exactly the same structure as the linear, stationary problem and therefore all linear matrix solvers can also be used here. It is worthwhile to notice the analogy between solution and correction on the one hand and between right-hand side and defect on the other hand. The preconditioner has usually a similar sparse pattern as the matrix of the linear problem. Note, that every linear problem can be viewed as a linear one. In this case, the preconditioner is just the linear matrix itself <img class="formulaInl" alt="$J_h \equiv A_h$" src="form_37.png"/> and the newton scheme must and will converge in one single step.</p>
<p>In order to specify a problem, the user has to specify: </p><ul>
<li>
the computation of the preconditioner <img class="formulaInl" alt="$J_h(\vec{u}_h)$" src="form_38.png"/> for any <img class="formulaInl" alt="$\vec{u}_h$" src="form_39.png"/> </li>
<li>
the computation of the defect <img class="formulaInl" alt="$\vec{d}_h(\vec{u}_h)$" src="form_40.png"/> for any <img class="formulaInl" alt="$\vec{u}_h$" src="form_39.png"/> </li>
</ul>
<p>All the other steps can be implemented independently from the actual problem and/or discretization.</p>
<hr  />
 <h1><a class="anchor" id="secTimeDiscretization"></a>
Time Discretization</h1>
<hr  />
<p>The discretization of time-dependent part of a PDE is closely related to the solution of ordinary differential equations (ODE). Those have the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \partial_t u(t) &amp;= - f(t, u(t)) \\ u(t_{start}) &amp;= u_0 \end{align*}" src="form_41.png"/>
</p>
<p> where the unknown function is <img class="formulaInl" alt="$u: \mathbb{R} \mapsto \mathbb{R}^N$" src="form_42.png"/> and the right-hand side is <img class="formulaInl" alt="$: \mathbb{R} \times \mathbb{R}^N \mapsto \mathbb{R}^N$" src="form_43.png"/>.</p>
<p>In order to discretize such an ODE introduce a time grid <img class="formulaInl" alt="$\{t_0 = t_{start}, t_1, t_2, \ldots \}$" src="form_44.png"/> and define the time step size <img class="formulaInl" alt="$\Delta t^k := t_{k} - t_{k-1}$" src="form_45.png"/>. Let <img class="formulaInl" alt="$u^{(k)} \approx u(t_k)$" src="form_46.png"/> be the approximation of <img class="formulaInl" alt="$u$" src="form_47.png"/> at time step k. A general L-step discretization scheme for ODEs takes the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{l=0}^{L-1} \left[ s_{m,l} u^{(k-l)} + s_{a,l} f(t^{k-l}, u^{(k-l)}) \right] = 0. \end{align*}" src="form_48.png"/>
</p>
<p> where </p><ul>
<li>
<img class="formulaInl" alt="$L \geq 2$" src="form_49.png"/> is the number of previous time steps needed </li>
<li>
<img class="formulaInl" alt="$s_{m,l}, s_{a,l} \in \mathbb{R}$" src="form_50.png"/> are scheme specific scaling factors </li>
<li>
<img class="formulaInl" alt="$u^{(k)}$" src="form_51.png"/> is the unknown solution at timestep <img class="formulaInl" alt="$t_k$" src="form_52.png"/> </li>
<li>
<img class="formulaInl" alt="$u^{(k-l)} (l \geq 1)$" src="form_53.png"/> are the known solutions at previous timesteps </li>
</ul>
<p>Denote by <img class="formulaInl" alt="$\vec{s} := (s_0, s_1, \ldots, s_{L-1})$" src="form_54.png"/> the specific scaling factors.</p>
<p>Some common schemes are </p><ul>
<li>
implicit Euler: <img class="formulaInl" alt="$ u^{k} - u^{k-1} + \Delta t^k f(t^k, u^k) = 0 $" src="form_55.png"/> This gives <img class="formulaInl" alt="$L = 2$" src="form_56.png"/> and <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \vec{s}_a &amp;= (\Delta t^k, 0)\\ \vec{s}_m &amp;= (1, -1) \end{align*}" src="form_57.png"/>
</p>
 </li>
<li>
explicit Euler: <img class="formulaInl" alt="$ u^{k} - u^{k-1} + \Delta t^k f(t^{k-1}, u^{k-1}) = 0 $" src="form_58.png"/> This gives <img class="formulaInl" alt="$L = 2$" src="form_56.png"/> and <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \vec{s}_a &amp;= (0, \Delta t^k)\\ \vec{s}_m &amp;= (1, -1) \end{align*}" src="form_59.png"/>
</p>
 </li>
<li>
Crank-Nicolson: <img class="formulaInl" alt="$ u^{k} - u^{k-1} + \frac{1}{2} \Delta t^k f(t^{k}, u^{k}) + \frac{1}{2} \Delta t^k f(t^{k-1}, u^{k-1}) = 0$" src="form_60.png"/><br  />
 This gives <img class="formulaInl" alt="$L = 2$" src="form_56.png"/> and <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \vec{s}_a &amp;= (\frac{1}{2} \Delta t^k, \frac{1}{2} \Delta t^k)\\ \vec{s}_m &amp;= (1, -1) \end{align*}" src="form_61.png"/>
</p>
 </li>
<li>
<img class="formulaInl" alt="$\theta$" src="form_62.png"/>-scheme: <img class="formulaInl" alt="$ u^{k} - u^{k-1} + \theta \Delta t^k f(t^{k}, u^{k}) + (1- \theta) \Delta t^k f(t^{k-1}, u^{k-1}) = 0$" src="form_63.png"/><br  />
 This gives <img class="formulaInl" alt="$L = 2$" src="form_56.png"/> and <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \vec{s}_a &amp;= (\theta \Delta t^k, (1- \theta)\Delta t^k)\\ \vec{s}_m &amp;= (1, -1) \end{align*}" src="form_64.png"/>
</p>
 with implements the three forementioned schemes by specifing <img class="formulaInl" alt="$ \theta$" src="form_65.png"/>. </li>
<li>
BDF(2): <img class="formulaInl" alt="$ u^{k} - \frac{4}{3}u^{k-1} + \frac{1}{3}u^{k-2} + \frac{2}{3} \Delta t^k f(t^{k}, u^{k}) = 0$" src="form_66.png"/> This gives <img class="formulaInl" alt="$L = 3$" src="form_67.png"/> and <p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \vec{s}_a &amp;= (\frac{2}{3} \Delta t^k, 0, 0)\\ \vec{s}_m &amp;= (1, -\frac{4}{3}, \frac{1}{3}) \end{align*}" src="form_68.png"/>
</p>
 </li>
<li>
Runge-Kutta schemes (e.g. DIRK(2)) </li>
<li>
Linear multi-step schemes like Adams-Bashforth or Adams-Moulton </li>
</ul>
<p><br  />
</p>
<p>Now assume <img class="formulaInl" alt="$\mathcal{M}(u)$" src="form_69.png"/> to have the form <img class="formulaInl" alt="$\frac{\partial}{\partial t} u$" src="form_70.png"/>. One can rearrange the problem to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathcal{M}(u) = \frac{\partial}{\partial t} u = - \mathcal{A}(u, t) + f(t) \end{align*}" src="form_71.png"/>
</p>
<p> and finds the setup for an ODE problem in time.</p>
<p>Discretize the time-dependent PDE problem first in space. This gives </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \frac{\partial}{\partial t} M_h \vec{u}_h(t) = - \mathcal{A}_h(\vec{u}_h(t), t) + f_h(t). \end{align*}" src="form_72.png"/>
</p>
<p> Supposing that the Mass-matrix is independent of time one can apply the ODE time stepping scheme and gets the next time step by solving</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \vec{d}_h(\vec{u}_h^{(k)}) := \sum_{l=0}^{L-1} \left[ s_{m,l} M_h \vec{u}_h^{(k-l)} + s_{a,l} \left( \mathcal{A}_h(\vec{u}^{(k-l)}, t^{(k-l)}) - \vec{f}_h(t^{(k-l)}) \right) \right] = 0. \end{align*}" src="form_73.png"/>
</p>
<p>The defect <img class="formulaInl" alt="$\vec{d}(u_h^{(k)})$" src="form_74.png"/> can be split up into </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \vec{d}_h(\vec{u}_h^{(k)}) := \sum_{l=0}^{L-1} \hat{\vec{d}}_h(\vec{u}_h^{(k-l)}, t^{(k-l)}, s_{m,l}, s_{a,l}) \end{align*}" src="form_75.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \hat{\vec{d}}_h(\vec{u}_h, t, s_m, s_a) := s_m M_h \vec{u}_h + s_a \left( \mathcal{A}_h(\vec{u}, t) - \vec{f}_h(t) \right) \end{align*}" src="form_76.png"/>
</p>
<p>For the Jacobian one finds </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} J_h(\vec{u}_h^{(k)}, t^k, s_{m,0}, s_{a,0}) = \frac{\partial \vec{d}_h(\vec{u}_h)}{\partial \vec{u}_h} \left( \vec{u}_h^{(k)} \right) = \frac{\partial \hat{\vec{d}}_h(\vec{u}_h, t^k, s_{m,0}, s_{a,0})} {\partial \vec{u}_h} \left( \vec{u}_h^{(k)} \right) = s_{m,0} M_h + s_{a,0} \frac{\partial \mathcal{A}_h(\vec{u}_h, t^k)}{\partial \vec{u}_h} \left( \vec{u}_h^{(k)} \right) \end{align*}" src="form_77.png"/>
</p>
<p>Thus, in order to specify a problem, the user has to specify: </p><ul>
<li>
the computation of the preconditioner <img class="formulaInl" alt="$J_h(\vec{u}_h, t, s_m, s_a)$" src="form_78.png"/> for any <img class="formulaInl" alt="$\vec{u}_h, t, s_m, s_a$" src="form_79.png"/> </li>
<li>
the computation of the defect <img class="formulaInl" alt="$\hat{\vec{d}}_h(\vec{u}_h, t, s_m, s_a)$" src="form_80.png"/> for any <img class="formulaInl" alt="$\vec{u}_h, t, s_m, s_a$" src="form_79.png"/> </li>
</ul>
<p><br  />
</p>
<hr  />
 <h1><a class="anchor" id="secTimeDependentLinearDiscretization"></a>
Time-Dependent Linear Problems</h1>
<p>If the time-dependent problem is linear if <img class="formulaInl" alt="$\mathcal{M}(\cdot)$" src="form_81.png"/> and <img class="formulaInl" alt="$\mathcal{A}(\cdot)$" src="form_82.png"/> are linear. In this case one finds <img class="formulaInl" alt="$\mathcal{A}(\vec{u}_h) \equiv A_h \vec{u}_h$" src="form_83.png"/>.</p>
<p>The defect equation can now be written in the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} s_{m,0} M_h \vec{u}_h^{(k)} + s_{a,0} A_h \vec{u}_h^{(k)} = s_{a,0} \vec{f}_h^{(k)} - \sum_{l=1}^{L-1} \left[ s_{m,l} M_h \vec{u}_h^{(k-l)} + s_{a,l} \left( A_h \vec{u}^{(k-l)} - \vec{f}_h^{(k-l)} \right) \right] \end{align*}" src="form_84.png"/>
</p>
<p> This system of equations has the form </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} B_h \vec{u}_h^{(k)} = b_h \end{align*}" src="form_85.png"/>
</p>
<p> where </p><ul>
<li>
<img class="formulaInl" alt="$B_h:=s_{m,0} M_h+ s_{a,0} A_h $" src="form_86.png"/> is a matrix </li>
<li>
<img class="formulaInl" alt="$b_h:= s_{a,0} \vec{f}_h^{(k)} - \sum_{l=1}^{L-1} \left[ s_{m,l} M_h \vec{u}_h^{(k-l)} + s_{a,l} \left( A_h \vec{u}^{(k-l)} - \vec{f}_h^{(k-l)} \right) \right]$" src="form_87.png"/> is a known vector right-hand side </li>
</ul>
<p>The problem can thus be solved using the same matrix solvers used for the stationary linear problems.</p>
<hr  />
 <h1><a class="anchor" id="secTimeDependentNonLinearDiscretization"></a>
Time-Dependent Non-Linear Problems</h1>
<p>In this case the defect equation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \vec{d}_h(\vec{u}_h^{(k)}) := \sum_{l=0}^{L-1} \left[ s_{m,l} M_h \vec{u}_h^{(k-l)} + s_{a,l} \left( \mathcal{A}_h(\vec{u}^{(k-l)}, t^{(k-l)}) - \vec{f}_h^{(k-l)} \right) \right] = 0 \end{align*}" src="form_88.png"/>
</p>
<p> has to be solved using a newton scheme. Fixing the time step <img class="formulaInl" alt="$k$" src="form_89.png"/> this problem has the same structure as the stationary non-linear problems. Thus, the solver framework can be reused.</p>
<hr  />
 <h1><a class="anchor" id="secCategorizationAcknowledgment"></a>
Acknowledgment</h1>
<p>This splitting concept is strongly influenced by a short but very illuminative paper by Dmitriy Logashenko. Special thanks to him for sharing his insight. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">ug4 - Documentation</a></li><li class="navelem"><a class="el" href="page_u_g4_development.html">Development</a></li><li class="navelem"><a class="el" href="page_l_d_introduction.html">libDiscretization</a></li><li class="navelem"><a class="el" href="page_l_d_assembling_concept.html">Assembling Concept</a></li>
    <li class="footer">Generated on Fri Dec 23 2022 16:05:51 for ug4 by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
